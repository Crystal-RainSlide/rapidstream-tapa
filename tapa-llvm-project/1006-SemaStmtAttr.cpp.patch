--- a/clang/lib/Sema/SemaStmtAttr.cpp	2023-11-28 00:52:28.000000000 -0800
+++ b/clang/lib/Sema/SemaStmtAttr.cpp	2024-06-18 12:50:08.994988022 -0700
@@ -24,6 +24,47 @@
 using namespace clang;
 using namespace sema;
 
+/// If Expr is a valid integer constant, get the value of the integer
+/// expression and return success or failure. May output an error.
+///
+/// Negative argument is implicitly converted to unsigned, unless
+/// \p StrictlyUnsigned is true.
+template <typename AttrInfo>
+static bool checkUInt32Argument(Sema &S, const AttrInfo &AI, const Expr *Expr,
+                                uint32_t &Val, unsigned Idx = UINT_MAX,
+                                bool StrictlyUnsigned = false) {
+  if (Expr->isTypeDependent() || Expr->isValueDependent() ||
+      !Expr->isIntegerConstantExpr(S.Context)) {
+    if (Idx != UINT_MAX)
+      S.Diag(AI.getLoc(), diag::err_attribute_argument_type)
+          << AI << AANT_ArgumentIntegerConstant << Expr->getSourceRange();
+    else
+      S.Diag(AI.getLoc(), diag::err_attribute_argument_type)
+          << AI << AANT_ArgumentIntegerConstant << Expr->getSourceRange();
+    return false;
+  }
+
+  auto I = Expr->getIntegerConstantExpr(S.Context);
+  if (!I.has_value())
+    return false;
+  auto &IVal = I.value();
+
+  if (!IVal.isIntN(32)) {
+    S.Diag(AI.getLoc(), diag::err_attribute_argument_type)
+        << AI << AANT_ArgumentIntegerConstant << Expr->getSourceRange();
+    return false;
+  }
+
+  if (StrictlyUnsigned && IVal.isSigned() && IVal.isNegative()) {
+    S.Diag(AI.getLoc(), diag::err_attribute_requires_positive_integer)
+        << AI << /*non-negative*/ 1;
+    return false;
+  }
+
+  Val = (uint32_t)IVal.getZExtValue();
+  return true;
+}
+
 static Attr *handleFallThroughAttr(Sema &S, Stmt *St, const ParsedAttr &A,
                                    SourceRange Range) {
   FallThroughAttr Attr(S.Context, A);
@@ -174,6 +215,50 @@
   return LoopHintAttr::CreateImplicit(S.Context, Option, State, ValueExpr, A);
 }
 
+// Begin TAPA
+
+static Attr *handleTapaPipelineAttr(Sema &S, Stmt *St, const ParsedAttr &A,
+                                    SourceRange) {
+  uint32_t ii = 0;
+  if (A.getNumArgs()) {
+    if (!checkUInt32Argument(S, A, A.getArgAsExpr(0), ii))
+      return nullptr;
+  }
+
+  if (St->getStmtClass() != Stmt::DoStmtClass &&
+      St->getStmtClass() != Stmt::ForStmtClass &&
+      St->getStmtClass() != Stmt::CXXForRangeStmtClass &&
+      St->getStmtClass() != Stmt::WhileStmtClass) {
+    S.Diag(St->getBeginLoc(), diag::warn_attribute_type_not_supported)
+        << A << "unsupported pipeline target";
+    return nullptr;
+  }
+
+  return ::new (S.Context) TapaPipelineAttr(S.Context, A, ii);
+}
+
+static Attr *handleTapaUnrollAttr(Sema &S, Stmt *St, const ParsedAttr &A,
+                                  SourceRange) {
+  uint32_t factor = 0;
+  if (A.getNumArgs()) {
+    if (!checkUInt32Argument(S, A, A.getArgAsExpr(0), factor))
+      return nullptr;
+  }
+
+  if (St->getStmtClass() != Stmt::DoStmtClass &&
+      St->getStmtClass() != Stmt::ForStmtClass &&
+      St->getStmtClass() != Stmt::CXXForRangeStmtClass &&
+      St->getStmtClass() != Stmt::WhileStmtClass) {
+    S.Diag(St->getBeginLoc(), diag::warn_attribute_type_not_supported)
+        << A << "unsupported unroll target";
+    return nullptr;
+  }
+
+  return ::new (S.Context) TapaUnrollAttr(S.Context, A, factor);
+}
+
+// End TAPA
+
 namespace {
 class CallExprFinder : public ConstEvaluatedExprVisitor<CallExprFinder> {
   bool FoundAsmStmt = false;
@@ -523,6 +608,10 @@
     return handleLikely(S, St, A, Range);
   case ParsedAttr::AT_Unlikely:
     return handleUnlikely(S, St, A, Range);
+  case ParsedAttr::AT_TapaPipeline:
+    return handleTapaPipelineAttr(S, St, A, Range);
+  case ParsedAttr::AT_TapaUnroll:
+    return handleTapaUnrollAttr(S, St, A, Range);
   default:
     // N.B., ClangAttrEmitter.cpp emits a diagnostic helper that ensures a
     // declaration attribute is not written on a statement, but this code is
