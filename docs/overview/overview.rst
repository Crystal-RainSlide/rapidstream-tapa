Overview
------------------

There are two key components in the RapidStream TAPA framework:

- The TAPA frontend provides API for expressing task-parallel accelerators in C++ and compiles the design into Verilog RTL.
- The RapidStream backend optimizes the generated RTL for high frequency and partitions the design for parallel placement and routing.

The TAPA frontend can be used standalone as an HLS tool, while the RapidStream backend can be optionally used to
maximize the achievable frequency of TAPA designs.

.. image:: https://github.com/rapidstream-org/doc-figures/blob/main/1.png?raw=true
  :width: 100 %

TAPA
------------------

TAPA programs describe parallel HLS ``tasks`` communicating through ``streams``. TAPA
compiler synthesizes the program into standalone and fully-functional Verilog RTL.

- A ``stream`` is essentially a FIFO
- A ``task`` consumes input data from some ``streams``, perform computation,
  then produces output data to some other ``streams``.
- All ``tasks`` execute in parallel and communicate with each other through
  ``streams``.


.. image:: https://user-images.githubusercontent.com/32432619/167315788-4f4c7241-d7bb-454d-80d2-94a3eae505a5.png
  :width: 100 %


RapidStream
------------

RapidStream performs the partition-and-pipeline optimization on the RTL generated by TAPA.
RapidStream automatically floorplan the design across the FPGA to achieve balanced resource utilization
and insert pipeline registers between tasks to maximize the frequency.

.. image:: https://github.com/rapidstream-org/doc-figures/blob/main/2.png?raw=true
  :width: 100 %

The partition-and-pipeline methodology works because it **reduces local congestion** and **fixes global critical paths** at the same time.

In the partition stage, the optimization engine ensures that all slots of the device have balanced utilization. In other words, this stage spread out the logic to the entire device. This steps avoids the situation where some FPGA regions are over-crowded while other regions are under-utilized.

When we spread the logic out, we will inevitably create wires that span long distances. Therefore, it is critical that the pipeline stage inject registers to break the long wires based on the pipeline flexibility. The following two examples demonstrate the power of the partition-and-pipeline methodology.

First, for the systolic array design we mentioned earlier, we show the implementation comparison with or without RapidStream. With the optimization from RapidStream, the design is well spread out to the full FPGA and local congestion is significantly reduced. The otherwise failed design now achieves 333 MHz (target clock period of 3 ns).

.. image:: https://github.com/rapidstream-org/doc-figures/blob/main/3.png?raw=true
  :width: 50 %

For the stencil design on U280, we visualize the interconnect congestion level comparison.
The redder the color in the picture, the more severe the routing congestion.
By intelligently force some logic away from the bottom SLR and adding adequate pipeline to the interconnects,
we improve again from routing failure to 250 MHz.

.. image:: https://github.com/rapidstream-org/doc-figures/blob/main/4.png?raw=true
  :width: 50 %
